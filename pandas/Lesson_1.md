Pandas - библиотека для работы с данными
---

[Официальная документация](https://pandas.pydata.org/pandas-docs/stable/)

Установка

    pip3 install pandas

Импорт

    import pandas as pd
---

В pandas есть 2 структуры данных:
1. Series (Ряды) 
2. DataFrame

---
Series
---
> Series – это маркированная одномерная структура данных, ее можно представить,
> как таблицу с одной строкой. С ним можно работать как с массивом, обращаться 
> по индексу, и как с ассоциированным массивом обращаться по ключам.

Создать `Series` можно из следующих объектов: 

1. Словари `Python`; 
2. Списки `Python`; 
3. Массивы из `numpy ndarray`;

Ряд можно создать из списка, тогда и обращаться с ним можно как со списком
по индексу :

```python
import pandas as pd

list1 = [1, 2, 3, 4, 5]
s1 = pd.Series(list1)

print(s1[1])
print(s1)

# Вывод
# 
# 2
# 
# 0    1
# 1    2
# 2    3
# 3    4
# 4    5
# dtype: int64
```

Можно создать Ряд в форме словаря, и работать с ним как со словарем,
для этого передадим вторым аргументом набор строк.
```python
import pandas as pd

values = [1, 2, 3, 4, 5]
keys = ['a', 'b', 'c', 'd', 'e']
s1 = pd.Series(values, index=keys)

print(s1)

print('a = ', s1['a'])
print('c = ', s1['c'])

# Вывод
# a    1
# b    2
# c    3
# d    4
# e    5
# dtype: int64
# a =  1
# c =  3
```

Если значения для ключей не заданы то `pd` принимает их за целочисленные значений,
`dtype` - это указание какого типа содержатся данные в таком массиве, для
чисел это к примеру `int64`

Через атрибуты `index` и `values` мы можем увидеть значения и ключ нашего массива.

```python
d1 = [5, 6, 7, 8, 9, 10]

my_series = pd.Series(d1)

print(my_series.index)
print(my_series.values)

# RangeIndex(start=0, stop=6, step=1)
# [ 5  6  7  8  9 10]
```

С помощью ключей мы можем получать выборку нужных элементов, и задавать новые значения
группе элементов по этим индексам, следующим образом :

```python
val = [5, 6, 7, 8, 9, 10]
index = ['a', 'b', 'c', 'd', 'e', 'f']

my_series = pd.Series(val, index=index)

print(my_series[['a', 'c', 'f']])

my_series[['a', 'c', 'f']] = 0

print(my_series)

# Вывод
#a     5
#c     7
#f    10
#dtype: int64
#
#a    0
#b    6
#c    0
#d    8
#e    9
#f    0
#dtype: int64
```

---
Можно получить информацию о состоянии данных, к примеру нас интересует какие значения
больше чем `8` сделать это мы можем с помощью выражения сравнения `my_series > 8`
которое вернет нам массив с информацией какие из полей соответствуют указанному условию.

```python
val = [5, 6, 7, 8, 9, 10]
index = ['a', 'b', 'c', 'd', 'e', 'f']

my_series = pd.Series(val, index=index)

result = my_series[my_series > 8]

print(result)
print(my_series > 8)

# Вывод
e     9
f    10
dtype: int64

a    False
b    False
c    False
d    False
e     True
f     True
dtype: bool
```

---

Мы можем фильтровать данные передавая в качестве среза выражение для фильтрации,
следующим образом

```python
result = my_series[my_series > 8]
print(result)

# Вывод
#e     9
#f    10
#dtype: int64
```

---
Выбрать нужные данные соответствующие некому условию, и произвести их 
трансформацию, это можно сделать сразу применяя условия фильтрации данных,
и арифметической операции над ними.

```python
val = [5, 6, 7, 8, 9, 10]
index = ['a', 'b', 'c', 'd', 'e', 'f']

my_series = pd.Series(val, index=index)
result = my_series[my_series > 8] * 2
print(result)

# Вывод
e    18
f    20
dtype: int64
```

---
DataFrame
---
> DataFrame - это двумерная маркированная структура. Представляет собой 
> таблицу схожую с таблицами БД.


---
Парсинг файла `Excel`  
---
С помощью `pandas` можно парсить `Excel` файл,

```python
    import pandas as pd

    path = 'Путь к файлу'
    sheet_name = 'название страницы'

    # получаем записи в виде словарей, {столбец:ячейка} из указанной страницы
    df = pd.read_excel(path, na_filter=False, sheet_name=sheet_name)
    
    df = df.to_dict(orient='index')
```

`pd.read_excel` - метод парсит файл, с указанием пути и страницы к файлу. 

- `na_filter=False` параметр указывает заменять пустые значение с типа `nan` на
пустые строки `''`

`df.to_dict()` - метод превращает `dataframe` в некое подобие словаря.

- `orient='index'` параметр указывает что требуется превратить `dataframe` в
список со словарями, где каждый из словарей это строка из файла `Excel` где
ключ это название столбца, а значение это значение ячейки конкретной строки.

---

Мы можем заменять значения в указанных столбцах, сделать это можно с помощью
указания столбца как ключа в словаре, заменим на строку.
```python
    df['ВРИ'] = df['ВРИ'].str.replace('', 'новое значение')
```
Замена на любое значение, в том числе и `None`
```python
    df['ВРИ'] = df['ВРИ'].str.replace('', None)
```

---
Замена `Nat` на `None`
---

Есть `Dataframe` который требуется очистить от типа данных `pd.NaT` и заменить их на
`None`, скажем для того что бы иметь в столбце только тип даты/времени или `None`.

```python
df[field] = df[field].astype(object).where(df[field].notnull(), None)
```

----
Привести данные к числовому типу
---
Если требуется привести данные к числовому типу, как `int` или `float`, те данные 
что возможно будут приведены к числу, те что привести нельзя будут приведены к типу
`Nan`, если тип `Nan` не требуется то можно заменить `Nan` к стандартному для 
`python` типу `None`

```python
df[field] = pd.to_numeric(df[field], errors='raise', downcast=None)

# приводим к типу None если требуется 
df[field] = df[field].astype(object).where(df[field].notnull(), None)
```

----
Привести данные типу даты/времени
---
Если требуется привести данные к типу даты/времени. Если данные привести к типу
даты/времени невозможно они будут приведены к `Nan`

```python
df[field] = pd.to_datetime(
                           df[field], 
                           format=settings.DATE_INPUT_FORMATS, 
                           infer_datetime_format=True, 
                           errors='raise'
                        )

# приводим к типу None если требуется
df[field] = df[field].astype(object).where(df[field].notnull(), None)
```

---
Нормализация и потеря строковых данных
---
При обработке данных, хорошим тоном является их нормализация, к примеру обрезание 
строк от пробелов по сторонам, для подобной обработке в `pandas` используется метод
`strip()` который обрезает строку с обоих концов, вызвать его можно `.str.strip()`
нужного поля.

```python
df['field'] = df['field'].str.strip()
```

Когда `df` имеет множество разных данных с разнами типами, может возникнуть ситуация
когда мы хотим получить данные в строковом виде, но сами данные содержатся в виде 
числа, то метод `.str.strip()` при попытке обрезать число, автоматически преобразует
значение в `nan`.

Это может иметь критическое значение когда происходит обработка данных для 
последующего хранения в БД, для того чтобы избежать этого можно явно преобразовать 
тип данных в строковое представление, сделать это можно методом `.astype(str)`,
с начала мы преобразуем данные в строку чем бы они не были, и только после этого
обрезаем их.

```python
df['field'] = df['field'].astype(str).str.strip()
```

Для обработки множества полей `df`, в нужный тип с последующей нормализацией,
в качестве ключа для `df` можно указывать целые списки с полями для обработки,
и `lambda` функцию для преобразования

```python
# преобразует все указанные поля в df в строковый тип данных и обрежет пробелы
field_str = ['field_1', 'field_2', 'field_3', 'field_4']
df[field_str] = df[field_str].apply(lambda x: x.astype(str).str.strip())
```
